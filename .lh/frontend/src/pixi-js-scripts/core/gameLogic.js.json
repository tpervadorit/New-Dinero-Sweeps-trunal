{
    "sourceFile": "frontend/src/pixi-js-scripts/core/gameLogic.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1754364715383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1754364715383,
            "name": "Commit-0",
            "content": "/* eslint-disable no-undef */\r\n/* eslint-disable no-unused-expressions */\r\n'use client';\r\nimport * as UI from './gameUI.js';\r\nimport { pixiApp } from './initializePixi.js';\r\nimport { spinWheelGCSettings, spinWheelSCSettings } from '../settings.js';\r\nimport { getStateAndDispatch } from '@/store/index.js';\r\nimport { getSpinWheelResultData } from '@/services/postRequest.js';\r\n\r\nexport const GAME_STATES = {\r\n  IDLE: 'idle',\r\n  SPIN: 'spin',\r\n  SUSPENDED: 'suspended',\r\n  INVISIBLE: 'invisible',\r\n  STOPPING: 'stopping',\r\n  STOP: 'stop',\r\n  REWARDPOPUP: 'rewardpopUp',\r\n};\r\nlet spinResult = {};\r\n\r\nexport const startSound = () => {\r\n  // useSpinWheelStore.getState().setSpinWheelSound(true);\r\n};\r\n\r\nconst stopSound = () => {\r\n  // useSpinWheelStore.getState().setSpinWheelSound(false);\r\n};\r\n\r\nconst playJackpotSound = () => {\r\n  // useSpinWheelStore.getState().setJackpotSound(true);\r\n  // setTimeout(() => useSpinWheelStore.getState().setJackpotSound(false), 3000);\r\n};\r\n\r\nexport const getSpinWheelResult = async () => {\r\n  try {\r\n    await getSpinWheelResultData().then((response) => {\r\n      if (response?.data?.message) {\r\n        const index = response?.data?.index;\r\n        const result = {\r\n          showResult: true,\r\n          index: response?.data?.index,\r\n          gc: response?.data?.wheelConfiguration?.gc,\r\n          sc: response?.data?.wheelConfiguration?.sc,\r\n          bonusActivated: response?.data?.bonusActivated,\r\n        };\r\n        spinWheel(indexMapping(index));\r\n        spinResult = result;\r\n        // useSpinWheelStore.getState().setShowClose(false);\r\n      }\r\n    });\r\n  } catch (e) {\r\n    console.log('PIXI: result error', e);\r\n  }\r\n};\r\n\r\nexport const scTextUI = [];\r\nexport const gcTextUI = [];\r\n\r\nconst indexMapping = (i) => {\r\n  let index = numberOfDiv - i;\r\n  return index > numberOfDiv - 1 ? index - numberOfDiv : index;\r\n};\r\n\r\n// let numberOfDiv = wheelContentValues.sc.length;\r\nlet numberOfDiv = 16;\r\nlet stopPoint;\r\nconst maxTime = 600;\r\nlet timer = false;\r\n\r\nexport let wheelState = GAME_STATES.IDLE;\r\nlet wheelSpeed = 0;\r\nlet spinNumber = 0;\r\nlet rounds = 0;\r\nlet defaultWheelSpeed = 8;\r\nconst reversePull = 0.0445;\r\n\r\nlet points = [];\r\nfor (let i = 0; i < numberOfDiv; i++) {\r\n  points[i] = (360 / numberOfDiv) * i;\r\n}\r\n\r\nexport function setupWheelValues(wheelContentValues) {\r\n  for (let num = 0; num < numberOfDiv; num++) {\r\n    scTextUI[num] = new PIXI.Text(\r\n      wheelContentValues.sc[num],\r\n      spinWheelSCSettings\r\n    );\r\n    scTextUI[num].anchor.set(0.5);\r\n    scTextUI[num].pivot.y = 373;\r\n    scTextUI[num].angle = (360 / numberOfDiv) * num;\r\n    UI.gameAssets.wheel.addChild(scTextUI[num]);\r\n    if (wheelContentValues.sc[num] === 0) {\r\n      scTextUI[num].text = '';\r\n    }\r\n\r\n    gcTextUI[num] = new PIXI.Text(\r\n      wheelContentValues.gc[num],\r\n      spinWheelGCSettings\r\n    );\r\n    gcTextUI[num].anchor.set(0.5);\r\n    gcTextUI[num].pivot.y = 510;\r\n    gcTextUI[num].angle = (360 / numberOfDiv) * num;\r\n    UI.gameAssets.wheel.addChild(gcTextUI[num]);\r\n    if (wheelContentValues.gc[num] === 0) {\r\n      gcTextUI[num].text = '';\r\n    }\r\n  }\r\n}\r\n\r\nfunction spinWheel(index = undefined) {\r\n  //TODO: SET STOP POINT HERE\r\n  if (index || index === 0) stopPoint = index;\r\n  else stopPoint = Math.floor(Math.random() * numberOfDiv);\r\n  spinNumber = 0;\r\n  rounds = 0;\r\n  wheelState = GAME_STATES.SPIN;\r\n}\r\nexport function spinSuspend() {\r\n  wheelSpeed = 0;\r\n  wheelState = GAME_STATES.SUSPENDED;\r\n}\r\n\r\nexport function resetWheel() {\r\n  UI.gameAssets.wheel.alpha = 1;\r\n  UI.gameAssets.wheel.interactive = true;\r\n  wheelState = GAME_STATES.IDLE;\r\n}\r\n\r\n//Callback function for result when the wheel stops\r\nfunction wheelStop() {\r\n  getStateAndDispatch().dispatch({type:'SET_SPIN_WHEEL_RESULT', payload: spinResult});\r\n  // useSpinWheelStore.getState().setShowClose(true);\r\n}\r\nfunction showReward() {\r\n  timer = true;\r\n}\r\nfunction timerCallback() {\r\n  wheelState = GAME_STATES.INVISIBLE;\r\n  wheelStop();\r\n}\r\n\r\nlet elapsedTime = 0;\r\n\r\nconst startGameTicker = () => {\r\n  pixiApp.app.ticker.add((delta) => {\r\n    if (rounds >= 2) {\r\n      rounds = 0;\r\n      wheelState = GAME_STATES.STOPPING;\r\n    }\r\n    if (wheelState === GAME_STATES.IDLE) {\r\n      if (UI.gameAssets.wheel.angle <= -360) {\r\n        UI.gameAssets.wheel.angle = 0;\r\n      } else UI.gameAssets.wheel.angle -= 0.2 * delta;\r\n    } else if (wheelState === GAME_STATES.SUSPENDED) {\r\n      if (UI.gameAssets.wheel.angle >= 360) {\r\n        spinNumber += 1;\r\n        UI.gameAssets.wheel.angle = 0;\r\n      } else {\r\n        if (wheelSpeed >= defaultWheelSpeed) {\r\n          wheelSpeed = defaultWheelSpeed;\r\n        } else wheelSpeed += 0.2 * delta;\r\n        UI.gameAssets.wheel.angle += wheelSpeed * delta;\r\n      }\r\n    } else if (wheelState === GAME_STATES.SPIN) {\r\n      if (UI.gameAssets.wheel.angle >= 360) {\r\n        spinNumber += 1;\r\n        UI.gameAssets.wheel.angle = 0;\r\n      } else {\r\n        if (wheelSpeed >= defaultWheelSpeed) {\r\n          wheelSpeed = defaultWheelSpeed;\r\n        } else wheelSpeed += 0.2 * delta;\r\n        UI.gameAssets.wheel.angle += wheelSpeed * delta;\r\n      }\r\n      if (\r\n        UI.gameAssets.wheel.angle >= points[stopPoint] - 5 &&\r\n        UI.gameAssets.wheel.angle <= points[stopPoint] + 5\r\n      ) {\r\n        rounds = spinNumber;\r\n      }\r\n    } else if (wheelState === GAME_STATES.STOPPING) {\r\n      if (UI.gameAssets.wheel.angle >= 360) UI.gameAssets.wheel.angle = 0;\r\n      else {\r\n        wheelSpeed -= reversePull * delta;\r\n        UI.gameAssets.wheel.angle += wheelSpeed * delta;\r\n        if (wheelSpeed <= 0.3) {\r\n          wheelSpeed = 0.3;\r\n          if (\r\n            UI.gameAssets.wheel.angle >= points[stopPoint] - 0.5 &&\r\n            UI.gameAssets.wheel.angle <= points[stopPoint] + 0.5\r\n          ) {\r\n            wheelState = GAME_STATES.STOP;\r\n            stopSound();\r\n            playJackpotSound();\r\n          }\r\n        }\r\n      }\r\n    } else if (wheelState === GAME_STATES.STOP) {\r\n      UI.gameAssets.wheel.angle = points[stopPoint];\r\n      showReward();\r\n    } else if (wheelState === GAME_STATES.INVISIBLE) {\r\n      UI.gameAssets.wheel.alpha >= 0\r\n        ? (UI.gameAssets.wheel.alpha -= 0.15 * delta)\r\n        : (wheelState = GAME_STATES.REWARDPOPUP);\r\n      UI.gameAssets.marker.alpha >= 0\r\n        ? (UI.gameAssets.marker.alpha -= 0.15 * delta)\r\n        : (wheelState = GAME_STATES.REWARDPOPUP);\r\n    }\r\n\r\n    if (timer) {\r\n      elapsedTime += 10 * delta;\r\n      if (elapsedTime >= maxTime) {\r\n        elapsedTime = 0;\r\n        timer = false;\r\n        timerCallback();\r\n      }\r\n    }\r\n  });\r\n\r\n  pixiApp.app.ticker.start();\r\n};\r\n\r\nconst stopGameTicker = () => pixiApp.app.ticker.stop();\r\n\r\nexport { startGameTicker, stopGameTicker };\r\n"
        }
    ]
}